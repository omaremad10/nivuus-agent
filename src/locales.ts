// filepath: /Projects/nivuus-agent/src/locales.js
export const strings = {
  en: {
    // General
    confirmExecute: "Confirm execution?",
    yesNo: "(yes/no)",
    pleaseAnswerYesNo: "Please answer 'yes' or 'no'.",
    executionCancelled: "Execution cancelled.",
    shuttingDown: "üëã Shutting down agent...",
    finalSaveCompleted: "üíæ Final save completed.",
    finalSaveError: "‚ùå Error during final save:",
    agentFinished: "Agent finished.",
    errorGettingInput: "Error getting user input:",
    invalidInputDefault: "Invalid or no user input received. Using default instruction.",
    usingDefaultInstruction: "Agent: Using default instruction: '{instruction}'",
    aiRequestsTool: "ü§ñ AI requests tool execution...",
    unknownFunctionRequested: "Error: Unknown function requested by AI: {functionName}",
    errorFunctionNotImplemented: "Error: Function '{functionName}' not implemented locally.",
    aiResponseNoContent: "AI response without text content or tool call.",
    errorApiKeyNotConfigured: "ERROR: OpenAI API Key not configured!",
    errorApiKeyInstructions: "Edit the OPENAI_API_KEY variable in the src/config.js file.",
    warningAxiosMissing: "Warning: 'axios' module required for web search (npm install axios).",
    agentStarted: "--- Agent {modelName} Started ---",
    mainScript: "Main script: {scriptFilename}",
    promptInstruction: "Enter your instruction or 'quit' to exit.",
    promptUser: "\nYou (Enter for '{defaultInstruction}', or 'quit'): ",
    defaultInstruction: "Let's get to work.",
    discoverSystem: "Discover the system you are running on.",
    proactiveDiscoverSystem: "Proactively discover the system you are running on by proposing and executing relevant commands.",
    sigintDetected: "\nüëã CTRL+C detected. Saving state before exiting...",
    saveCompleted: "üíæ Save completed.",
    saveError: "‚ùå Error during save:",
    exiting: "Exiting now.",
    memorySummaryTitle: "--- Internal Memory Summary ---",
    memorySysInfo: "Sys Info:",
    memoryNotes: "Notes:",
    memoryActionLog: "Action Log ({count}/{total}):",
    memoryActionLogEntry: "- {time}: [{statusColor}{actionType}/{status}{resetColor}] `{detail}`{errorInfo}", // Requires color handling or stripping
    memoryEndOfSummary: "--- End Summary ---",
    memoryReminder: "Reminder of current state and recent actions:",
    callingApi: "Calling OpenAI API...",
    apiResponseReceived: "API response received.",
    apiError: "OpenAI API Error.",
    toolExecuting: "Executing tool: {functionName}", // Changed {toolName} to {functionName}
    toolExecuted: "Tool {toolName} executed.",
    toolExecutionError: "Error executing tool {toolName}.",
    toolResponseTruncated: "‚Ü™ Tool response truncated ({length} > {maxLength})",
    exitRequestedAfterAction: "Exit requested after action (script update?).",
    errorArgsParsing: "Error parsing JSON arguments for {functionName}: {error}",
    errorArgsInvalidJson: "Error: Invalid arguments provided by AI (not JSON). Error: {message}",
    errorToolExecution: "Error during local tool execution: {message}",
    errorMainLoop: "\nUNEXPECTED MAIN LOOP ERROR:",
    errorApiGeneric: "\nOpenAI API Error ({status}): {message}",
    errorApi401: "ERROR 401: Check your OpenAI API key (OPENAI_API_KEY). Exiting.",
    errorApi429: "ERROR 429: API rate limit reached. Suggested wait before retrying.",
    errorInternalJsonParse: "\nInternal Error (JSON Parse Arguments?): {message}",
    errorOccurredRetrying: "\nAn error occurred. Attempting automatic retry...",
    errorRetryNoInstruction: "Could not find last user instruction for retry. Using default instruction.",
    errorRetryHistoryCleaned: "History restored and cleaned before last instruction for retry.",
    errorRetryCleanupAssistant: "Cleanup: Removing last assistant message with unresolved tool_calls before retry.",
    errorRetryResetHistory: "Cleanup: Resetting history (except system) as no user message found for retry.",
    aiAgentName: "ü§ñ {modelName}:",
    errorNoApiResponse: "Error: No API response received.",
    errorNoResponse: "Error: No response content found.",
    toolCallInitiated: "Tool call initiated...",
    toolSuccess: "Tool '{functionName}' executed successfully.",
    errorToolNotFound: "Error: Tool '{functionName}' not found.",
    sendingToolResults: "Sending tool results back to API...",
    receivedFinalResponse: "Received final response from API.",
    assistantResponseHeader: "--- Assistant Response ---",
    errorNoFinalResponse: "Error: No final response content received.",
    errorApiCallFailed: "API call failed.",
    errorUnknown: "An unknown error occurred.",
    // tools.js specific
    commandConfirmPrompt: "\n--- Command Confirmation ---",
    commandConfirmProposed: "Proposed command: $ {command}",
    commandConfirmPurpose: "Command purpose: {purpose}",
    notSpecified: "Not specified",
    commandStartExecution: "--- Start Execution: $ {command} ---",
    commandSpawnError: "\nError spawning process: {message}",
    commandTimeoutError: "\nERROR: Timeout ({timeout}s) exceeded! Process killed.",
    commandTimeoutErrorMsg: "SCRIPT ERROR: Timeout ({timeout}s) exceeded.",
    commandEndExecution: "\n--- End Execution (Code: {code}{signalInfo}) ---",
    commandRawOutputTitle: "--- Raw Output Captured ---",
    commandRawOutputEnd: "--- End Raw Output --- ",
    commandOutputStdout: "STDOUT:",
    commandOutputStderr: "STDERR:",
    commandOutputNoOutputCode: "(no output captured, code: {code}{signalInfo})",
    commandOutputNoOutputSuccess: "(no output captured, success)",
    readFileAttempt: "Attempting direct read: {path}",
    readFileNotFile: "Path is not a file.",
    readFileTooLarge: "File too large ({size} > {maxSize} bytes). Use shell commands (head, tail, grep) instead.",
    readFileBinary: "File appears to be binary. Cannot read content directly.",
    readFileEncodingError: "Could not decode with common encodings (utf-8, latin1).",
    readFileReadSuccess: "File read: {path}",
    readFileReadSuccessEncoding: "Read with {encoding} encoding.",
    readFileError: "Error reading file {path}: {message}",
    readFileContentHeader: "Content of '{path}':\n```\n{content}\n```",
    webSearchAttempt: "Performing web search for: '{query}'...",
    webSearchNoResults: "No web results found for '{query}'.",
    webSearchResultsTitle: "Web results for '{query}':",
    webSearchResultEntry: "{index}. {title}\n   {body}...\n   {href}",
    webSearchError: "Web search error for '{query}': {message}",
    webSearchHttpError: "HTTP Error {status}: {statusText}",
    webSearchTimeoutError: "Web request timeout exceeded.",
    listDirectoryAttempt: "Attempting to list directory: {path}",
    listDirectoryNotDir: "Specified path is not a directory.",
    listDirectoryEmpty: "(Directory is empty)",
    listDirectorySuccess: "Directory listed: {path}",
    listDirectoryError: "Error listing directory {path}: {message}",
    listDirectoryContentHeader: "Contents of '{path}':",
    listDirectoryEntry: "- {name}{isDir}",
    fileWriteConfirmPrompt: "\n--- File Write Confirmation ---",
    fileWriteConfirmProposed: "Proposed file write: {filepath}",
    fileWriteConfirmContent: "Content snippet:\n{contentSnippet}",
    confirmWrite: "Confirm write operation?",
    fileWriteCancelled: "File write cancelled.",
    fileWriteAttempt: "Attempting to write file: {filepath}",
    fileWriteSuccess: "Successfully wrote file: {filepath}",
    fileWriteError: "Error writing file {filepath}: {message}",

    // Memory Tools
    toolDescriptionGetMemoryKeys: "Lists the keys available under a specific path in the agent's internal memory. If no path is provided, lists keys at the root.",
    toolDescriptionGetMemoryValue: "Retrieves the value stored at a specific path in the agent's internal memory.",
    toolDescriptionSetMemoryValue: "Sets or updates a value at a specific path in the agent's internal memory. Creates nested paths if they don't exist.",
    toolParamMemoryPathOptional: "The dot-separated path to inspect (e.g., 'system_info.cpu') (optional, defaults to root).",
    toolParamMemoryPathRequired: "The dot-separated path for the value (e.g., 'system_info.cpu_model', 'notes').",
    toolParamMemoryValue: "The value to store (can be string, number, boolean, object, or array).",
    memoryGettingKeys: "Memory: Getting keys for path: {path}",
    errorMemoryNotInitialized: "Error: Agent memory reference is not initialized.",
    memoryPathNotFound: "Memory: Path not found: {path}",
    errorMemoryPathNotObject: "Error: Path does not point to an object, cannot list keys: {path}",
    memoryGetKeysSuccess: "Memory: Successfully retrieved keys for path: {path}",
    memoryGetKeysError: "Memory: Error getting keys for path {path}: {message}",
    memoryGetKeysErrorFeedback: "Error getting memory keys for {path}: {message}",
    memoryGettingValue: "Memory: Getting value for path: {path}",
    errorMemoryPathRequired: "Error: Memory path parameter is required.",
    memoryGetValueSuccess: "Memory: Successfully retrieved value for path: {path}",
    memoryGetValueError: "Memory: Error getting value for path {path}: {message}",
    memoryGetValueErrorFeedback: "Error getting memory value for {path}: {message}",
    memorySettingValue: "Memory: Setting value for path: {path}",
    memorySetValueSuccess: "Memory: Successfully set value for path: {path}",
    memorySetValueSuccessFeedback: "Successfully set memory value for path: {path}",
    memorySetValueError: "Memory: Error setting value for path {path}: {message}",
    memorySetValueErrorFeedback: "Error setting memory value for {path}: {message}",

    // utils.js specific
    fileNotFound: "File not found: {filePath}. Using default data.",
    errorLoadingData: "Error loading data from {filePath}:",
    errorSavingData: "Error saving data to {filePath}:",
    invalidMemoryUpdate: "Invalid memory object passed to updateMemory",

    // New strings for ask_user and auto-continue
    autoContinuePrompt: "Continue.",
    userRequestedQuit: "User requested quit via ask_user.",
    errorToolExecutionFailed: "Tool execution failed: {message}",
    askUserCalledLoopRestart: "ask_user was called, restarting loop with user response.",
    assistantQuestionPrefix: "Assistant Question:",
    promptUserResponse: "Your response: ",

    // Add missing key
    errorToolArgsParse: "Error parsing arguments for tool {functionName}. Args: {args}. Error: {message}",

    // Add missing confirmation keys
    commandConfirmYes: "yes",
    commandConfirmNo: "no",
  },
  fr: {
    // General
    confirmExecute: "Confirmer l'ex√©cution ?",
    yesNo: "(oui/non)",
    pleaseAnswerYesNo: "Veuillez r√©pondre par 'oui' ou 'non'.",
    executionCancelled: "Ex√©cution annul√©e.",
    shuttingDown: "üëã Arr√™t de l'agent...",
    finalSaveCompleted: "üíæ Sauvegarde finale termin√©e.",
    finalSaveError: "‚ùå Erreur lors de la sauvegarde finale :",
    agentFinished: "Agent termin√©.",
    errorGettingInput: "Erreur lors de la r√©cup√©ration de l'entr√©e utilisateur :",
    invalidInputDefault: "Entr√©e utilisateur invalide ou absente. Utilisation de l'instruction par d√©faut.",
    usingDefaultInstruction: "Agent : Utilisation de l'instruction par d√©faut : '{instruction}'",
    aiRequestsTool: "ü§ñ L'IA demande l'ex√©cution d'un outil...",
    unknownFunctionRequested: "Erreur : Fonction inconnue demand√©e par l'IA : {functionName}",
    errorFunctionNotImplemented: "Erreur : La fonction '{functionName}' n'est pas impl√©ment√©e localement.",
    aiResponseNoContent: "R√©ponse de l'IA sans contenu texte ni appel d'outil.",
    errorApiKeyNotConfigured: "ERREUR : Cl√© API OpenAI non configur√©e !",
    errorApiKeyInstructions: "Modifiez la variable OPENAI_API_KEY dans le fichier src/config.js.",
    warningAxiosMissing: "Attention : Le module 'axios' est requis pour la recherche web (npm install axios).",
    agentStarted: "--- Agent {modelName} d√©marr√© ---",
    mainScript: "Script principal : {scriptFilename}",
    promptInstruction: "Entrez votre instruction ou 'quit' pour quitter.",
    promptUser: "\nVous (Entr√©e pour '{defaultInstruction}', ou 'quit') : ",
    defaultInstruction: "Au travail.",
    discoverSystem: "D√©couvrir le syst√®me sur lequel vous fonctionnez.",
    proactiveDiscoverSystem: "D√©couvre proactivement le syst√®me sur lequel tu fonctionnes en proposant et ex√©cutant des commandes pertinentes (comme 'uname -a', 'lsb_release -a', '/etc/os-release'). Demande confirmation avant d'ex√©cuter. Apr√®s avoir obtenu les infos de base sur l'OS, propose d'autres commandes pour explorer le mat√©riel (ex: 'lscpu', 'lspci', 'lsusb'), la m√©moire ('free -h'), l'utilisation disque ('df -h'), et la configuration r√©seau ('ip addr', 'ip route'), en demandant √† nouveau confirmation pour chaque groupe.",
    sigintDetected: "\nüëã CTRL+C d√©tect√©. Sauvegarde de l'√©tat avant de quitter...",
    saveCompleted: "üíæ Sauvegarde termin√©e.",
    saveError: "‚ùå Erreur lors de la sauvegarde :",
    exiting: "Fermeture en cours.",
    memorySummaryTitle: "--- R√©sum√© de la M√©moire Interne ---",
    memorySysInfo: "Infos Sys :",
    memoryNotes: "Notes :",
    memoryActionLog: "Journal d'Actions ({count}/{total}) :",
    memoryActionLogEntry: "- {time}: [{statusColor}{actionType}/{status}{resetColor}] `{detail}`{errorInfo}", // N√©cessite gestion couleur ou suppression
    memoryEndOfSummary: "--- Fin du R√©sum√© ---",
    memoryReminder: "Rappel de l'√©tat actuel et des actions r√©centes :",
    callingApi: "Appel de l'API OpenAI...",
    apiResponseReceived: "R√©ponse de l'API re√ßue.",
    apiError: "Erreur API OpenAI.",
    toolExecuting: "Ex√©cution de l'outil : {functionName}", // Changed {toolName} to {functionName}
    toolExecuted: "Outil {toolName} ex√©cut√©.",
    toolExecutionError: "Erreur lors de l'ex√©cution de l'outil {toolName}.",
    toolResponseTruncated: "‚Ü™ R√©ponse de l'outil tronqu√©e ({length} > {maxLength})",
    exitRequestedAfterAction: "Sortie demand√©e apr√®s action (mise √† jour script ?).",
    errorArgsParsing: "Erreur d'analyse des arguments JSON pour {functionName} : {error}",
    errorArgsInvalidJson: "Erreur : Arguments invalides fournis par l'IA (pas JSON). Erreur : {message}",
    errorToolExecution: "Erreur lors de l'ex√©cution locale de l'outil : {message}",
    errorMainLoop: "\nERREUR INATTENDUE BOUCLE PRINCIPALE :",
    errorApiGeneric: "\nErreur API OpenAI ({status}) : {message}",
    errorApi401: "ERREUR 401 : V√©rifiez votre cl√© API OpenAI (OPENAI_API_KEY). Arr√™t.",
    errorApi429: "ERREUR 429 : Limite de taux API atteinte. Attente sugg√©r√©e avant de r√©essayer.",
    errorInternalJsonParse: "\nErreur Interne (Analyse Arguments JSON ?) : {message}",
    errorOccurredRetrying: "\nUne erreur est survenue. Tentative de relance automatique...",
    errorRetryNoInstruction: "Impossible de trouver la derni√®re instruction utilisateur pour relancer. Utilisation de l'instruction par d√©faut.",
    errorRetryHistoryCleaned: "Historique restaur√© et nettoy√© avant la derni√®re instruction pour relance.",
    errorRetryCleanupAssistant: "Nettoyage : Suppression du dernier message assistant avec appels d'outils non r√©solus avant relance.",
    errorRetryResetHistory: "Nettoyage : R√©initialisation de l'historique (sauf syst√®me) car aucun message utilisateur trouv√© pour relance.",
    aiAgentName: "ü§ñ {modelName} :",
    errorNoApiResponse: "Erreur : Aucune r√©ponse de l'API re√ßue.",
    errorNoResponse: "Erreur : Aucun contenu de r√©ponse trouv√©.",
    toolCallInitiated: "Appel d'outil initi√©...",
    toolSuccess: "Outil '{functionName}' ex√©cut√© avec succ√®s.",
    errorToolNotFound: "Erreur : Outil '{functionName}' non trouv√©.",
    sendingToolResults: "Envoi des r√©sultats de l'outil √† l'API...",
    receivedFinalResponse: "R√©ponse finale re√ßue de l'API.",
    assistantResponseHeader: "--- R√©ponse Assistant ---",
    errorNoFinalResponse: "Erreur : Aucun contenu de r√©ponse final re√ßu.",
    errorApiCallFailed: "L'appel API a √©chou√©.",
    errorUnknown: "Une erreur inconnue est survenue.",
    // tools.js specific
    commandConfirmPrompt: "\n--- Confirmation Commande ---",
    commandConfirmProposed: "Commande propos√©e : $ {command}",
    commandConfirmPurpose: "Objectif commande : {purpose}",
    notSpecified: "Non sp√©cifi√©",
    commandStartExecution: "--- D√©but Ex√©cution : $ {command} ---",
    commandSpawnError: "\nErreur lancement processus : {message}",
    commandTimeoutError: "\nERREUR : Timeout ({timeout}s) d√©pass√© ! Processus tu√©.",
    commandTimeoutErrorMsg: "ERREUR SCRIPT : Timeout ({timeout}s) d√©pass√©.",
    commandEndExecution: "\n--- Fin Ex√©cution (Code : {code}{signalInfo}) ---",
    commandRawOutputTitle: "--- Sortie Brute Captur√©e ---",
    commandRawOutputEnd: "--- Fin Sortie Brute --- ",
    commandOutputStdout: "STDOUT :",
    commandOutputStderr: "STDERR :",
    commandOutputNoOutputCode: "(aucune sortie captur√©e, code : {code}{signalInfo})",
    commandOutputNoOutputSuccess: "(aucune sortie captur√©e, succ√®s)",
    readFileAttempt: "Tentative de lecture directe : {path}",
    readFileNotFile: "Le chemin n'est pas un fichier.",
    readFileTooLarge: "Fichier trop volumineux ({size} > {maxSize} octets). Utilisez des commandes shell (head, tail, grep) √† la place.",
    readFileBinary: "Le fichier semble √™tre binaire. Lecture directe impossible.",
    readFileEncodingError: "Impossible de d√©coder avec les encodages courants (utf-8, latin1).",
    readFileReadSuccess: "Fichier lu : {path}",
    readFileReadSuccessEncoding: "Lu avec l'encodage {encoding}.",
    readFileError: "Erreur lecture fichier {path} : {message}",
    readFileContentHeader: "Contenu de '{path}' :\n```\n{content}\n```",
    webSearchAttempt: "Recherche web pour : '{query}'...",
    webSearchNoResults: "Aucun r√©sultat web trouv√© pour '{query}'.",
    webSearchResultsTitle: "R√©sultats web pour '{query}' :",
    webSearchResultEntry: "{index}. {title}\n   {body}...\n   {href}",
    webSearchError: "Erreur recherche web pour '{query}' : {message}",
    webSearchHttpError: "Erreur HTTP {status} : {statusText}",
    webSearchTimeoutError: "Timeout de la requ√™te web d√©pass√©.",
    listDirectoryAttempt: "Tentative de lister le r√©pertoire : {path}",
    listDirectoryNotDir: "Le chemin sp√©cifi√© n'est pas un r√©pertoire.",
    listDirectoryEmpty: "(Le r√©pertoire est vide)",
    listDirectorySuccess: "R√©pertoire list√© : {path}",
    listDirectoryError: "Erreur listage r√©pertoire {path} : {message}",
    listDirectoryContentHeader: "Contenu de '{path}' :",
    listDirectoryEntry: "- {name}{isDir}",
    fileWriteConfirmPrompt: "\n--- Confirmation √âcriture Fichier ---",
    fileWriteConfirmProposed: "√âcriture de fichier propos√©e : {filepath}",
    fileWriteConfirmContent: "Extrait du contenu :\n{contentSnippet}",
    confirmWrite: "Confirmer l'op√©ration d'√©criture ?",
    fileWriteCancelled: "√âcriture de fichier annul√©e.",
    fileWriteAttempt: "Tentative d'√©criture du fichier : {filepath}",
    fileWriteSuccess: "Fichier √©crit avec succ√®s : {filepath}",
    fileWriteError: "Erreur lors de l'√©criture du fichier {filepath} : {message}",

    // Memory Tools
    toolDescriptionGetMemoryKeys: "Liste les cl√©s disponibles sous un chemin sp√©cifique dans la m√©moire interne de l'agent. Si aucun chemin n'est fourni, liste les cl√©s √† la racine.",
    toolDescriptionGetMemoryValue: "R√©cup√®re la valeur stock√©e √† un chemin sp√©cifique dans la m√©moire interne de l'agent.",
    toolDescriptionSetMemoryValue: "D√©finit ou met √† jour une valeur √† un chemin sp√©cifique dans la m√©moire interne de l'agent. Cr√©e les chemins imbriqu√©s s'ils n'existent pas.",
    toolParamMemoryPathOptional: "Le chemin s√©par√© par des points √† inspecter (ex: 'system_info.cpu') (optionnel, racine par d√©faut).",
    toolParamMemoryPathRequired: "Le chemin s√©par√© par des points pour la valeur (ex: 'system_info.cpu_model', 'notes').",
    toolParamMemoryValue: "La valeur √† stocker (peut √™tre cha√Æne, nombre, bool√©en, objet ou tableau).",
    memoryGettingKeys: "M√©moire : R√©cup√©ration des cl√©s pour le chemin : {path}",
    errorMemoryNotInitialized: "Erreur : La r√©f√©rence m√©moire de l'agent n'est pas initialis√©e.",
    memoryPathNotFound: "M√©moire : Chemin non trouv√© : {path}",
    errorMemoryPathNotObject: "Erreur : Le chemin ne pointe pas vers un objet, impossible de lister les cl√©s : {path}",
    memoryGetKeysSuccess: "M√©moire : Cl√©s r√©cup√©r√©es avec succ√®s pour le chemin : {path}",
    memoryGetKeysError: "M√©moire : Erreur lors de la r√©cup√©ration des cl√©s pour {path} : {message}",
    memoryGetKeysErrorFeedback: "Erreur r√©cup√©ration cl√©s m√©moire pour {path} : {message}",
    memoryGettingValue: "M√©moire : R√©cup√©ration de la valeur pour le chemin : {path}",
    errorMemoryPathRequired: "Erreur : Le param√®tre de chemin m√©moire est requis.",
    memoryGetValueSuccess: "M√©moire : Valeur r√©cup√©r√©e avec succ√®s pour le chemin : {path}",
    memoryGetValueError: "M√©moire : Erreur lors de la r√©cup√©ration de la valeur pour {path} : {message}",
    memoryGetValueErrorFeedback: "Erreur r√©cup√©ration valeur m√©moire pour {path} : {message}",
    memorySettingValue: "M√©moire : D√©finition de la valeur pour le chemin : {path}",
    memorySetValueSuccess: "M√©moire : Valeur d√©finie avec succ√®s pour le chemin : {path}",
    memorySetValueSuccessFeedback: "Valeur m√©moire d√©finie avec succ√®s pour le chemin : {path}",
    memorySetValueError: "M√©moire : Erreur lors de la d√©finition de la valeur pour {path} : {message}",
    memorySetValueErrorFeedback: "Erreur d√©finition valeur m√©moire pour {path} : {message}",

    // utils.js specific
    fileNotFound: "Fichier non trouv√© : {filePath}. Utilisation des donn√©es par d√©faut.",
    errorLoadingData: "Erreur chargement donn√©es depuis {filePath} :",
    errorSavingData: "Erreur sauvegarde donn√©es vers {filePath} :",
    invalidMemoryUpdate: "Objet m√©moire invalide pass√© √† updateMemory",

    // New strings for ask_user and auto-continue (French)
    autoContinuePrompt: "Continuer.",
    userRequestedQuit: "L'utilisateur a demand√© √† quitter via ask_user.",
    errorToolExecutionFailed: "L'ex√©cution de l'outil a √©chou√© : {message}",
    askUserCalledLoopRestart: "ask_user a √©t√© appel√©, red√©marrage de la boucle avec la r√©ponse utilisateur.",
    assistantQuestionPrefix: "Question Assistant :",
    promptUserResponse: "Votre r√©ponse : ",

    // Add missing key (French)
    errorToolArgsParse: "Erreur d'analyse des arguments pour l'outil {functionName}. Args: {args}. Erreur: {message}",

    // Add missing confirmation keys (French)
    commandConfirmYes: "oui",
    commandConfirmNo: "non",
  }
};
